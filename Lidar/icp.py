def icp(a, b,
        max_time = 1
    ):
    import cv2
    import numpy
    import copy
    import pylab
    import time
    import sys
    import sklearn.neighbors
    import scipy.optimize



    def res(p,src,dst):
        T = numpy.matrix([[numpy.cos(p[2]),-numpy.sin(p[2]),p[0]],
        [numpy.sin(p[2]), numpy.cos(p[2]),p[1]],
        [0 ,0 ,1 ]])
        n = numpy.size(src,0)
        xt = numpy.ones([n,3])
        xt[:,:-1] = src
        xt = (xt*T.T).A
        d = numpy.zeros(numpy.shape(src))
        d[:,0] = xt[:,0]-dst[:,0]
        d[:,1] = xt[:,1]-dst[:,1]
        r = numpy.sum(numpy.square(d[:,0])+numpy.square(d[:,1]))
        return r

    def jac(p,src,dst):
        T = numpy.matrix([[numpy.cos(p[2]),-numpy.sin(p[2]),p[0]],
        [numpy.sin(p[2]), numpy.cos(p[2]),p[1]],
        [0 ,0 ,1 ]])
        n = numpy.size(src,0)
        xt = numpy.ones([n,3])
        xt[:,:-1] = src
        xt = (xt*T.T).A
        d = numpy.zeros(numpy.shape(src))
        d[:,0] = xt[:,0]-dst[:,0]
        d[:,1] = xt[:,1]-dst[:,1]
        dUdth_R = numpy.matrix([[-numpy.sin(p[2]),-numpy.cos(p[2])],
                            [ numpy.cos(p[2]),-numpy.sin(p[2])]])
        dUdth = (src*dUdth_R.T).A
        g = numpy.array([  numpy.sum(2*d[:,0]),
                        numpy.sum(2*d[:,1]),
                        numpy.sum(2*(d[:,0]*dUdth[:,0]+d[:,1]*dUdth[:,1])) ])
        return g
    def hess(p,src,dst):
        n = numpy.size(src,0)
        T = numpy.matrix([[numpy.cos(p[2]),-numpy.sin(p[2]),p[0]],
        [numpy.sin(p[2]), numpy.cos(p[2]),p[1]],
        [0 ,0 ,1 ]])
        n = numpy.size(src,0)
        xt = numpy.ones([n,3])
        xt[:,:-1] = src
        xt = (xt*T.T).A
        d = numpy.zeros(numpy.shape(src))
        d[:,0] = xt[:,0]-dst[:,0]
        d[:,1] = xt[:,1]-dst[:,1]
        dUdth_R = numpy.matrix([[-numpy.sin(p[2]),-numpy.cos(p[2])],[numpy.cos(p[2]),-numpy.sin(p[2])]])
        dUdth = (src*dUdth_R.T).A
        H = numpy.zeros([3,3])
        H[0,0] = n*2
        H[0,2] = numpy.sum(2*dUdth[:,0])
        H[1,1] = n*2
        H[1,2] = numpy.sum(2*dUdth[:,1])
        H[2,0] = H[0,2]
        H[2,1] = H[1,2]
        d2Ud2th_R = numpy.matrix([[-numpy.cos(p[2]), numpy.sin(p[2])],[-numpy.sin(p[2]),-numpy.cos(p[2])]])
        d2Ud2th = (src*d2Ud2th_R.T).A
        H[2,2] = numpy.sum(2*(numpy.square(dUdth[:,0])+numpy.square(dUdth[:,1]) + d[:,0]*d2Ud2th[:,0]+d[:,0]*d2Ud2th[:,0]))
        return H
    t0 = time.time()
    init_pose = (0,0,0)
    src = numpy.array([a.T], copy=True).astype(numpy.float32)
    dst = numpy.array([b.T], copy=True).astype(numpy.float32)
    Tr = numpy.array([[numpy.cos(init_pose[2]),-numpy.sin(init_pose[2]),init_pose[0]],
                   [numpy.sin(init_pose[2]), numpy.cos(init_pose[2]),init_pose[1]],
                   [0,                    0,                   1          ]])
    # print("src",numpy.shape(src))
    # print("Tr[0:2]",numpy.shape(Tr[0:2]))
    src = cv2.transform(src, Tr[0:2])
    p_opt = numpy.array(init_pose)
    T_opt = numpy.array([])
    error_max = sys.maxsize
    first = False
    while not(first and time.time() - t0 > max_time):
        distances, indices = sklearn.neighbors.NearestNeighbors(n_neighbors=1, algorithm='auto',p = 3).fit(dst[0]).kneighbors(src[0])
        # print("distances: " + str(distances.shape))
        # print("indices: " + str(indices.shape))
        p = scipy.optimize.minimize(res,[0,0,0],args=(src[0],dst[0, indices.T][0]),method='Newton-CG',jac=jac,hess=hess).x
        T  = numpy.array([[numpy.cos(p[2]),-numpy.sin(p[2]),p[0]],[numpy.sin(p[2]), numpy.cos(p[2]),p[1]]])
        p_opt[:2]  = (p_opt[:2]*numpy.matrix(T[:2,:2]).T).A
        p_opt[0] += p[0]
        p_opt[1] += p[1]
        p_opt[2] += p[2]
        src = cv2.transform(src, T)
        Tr = (numpy.matrix(numpy.vstack((T,[0,0,1])))*numpy.matrix(Tr)).A
        error = res([0,0,0],src[0],dst[0, indices.T][0])
        # print("error: " + str(error))

        if error < error_max:
            error_max = error
            first = True
            T_opt = Tr

    p_opt[2] = p_opt[2] % (2*numpy.pi)
    return T_opt, error_max


if __name__ == '__main__':
    import cv2
    import numpy
    import random
    import matplotlib.pyplot

    template = numpy.array([[4415.2437566808985, 3860.2838034472925, 3805.0541017752444, 3780.732989080201, 3778.937597320844, 3766.9126731814117, 3812.256605248243, 3880.494344122582, 513.8925449645011, 493.91308959977135, 475.05176431226846, 454.24091430243374, 437.48743573238534, 417.3134452782861, 394.6999245754037, 371.84081372131493, 352.4236418822367, 334.78692493919596, 343.22727887537343, 307.3318823508407, 274.40666375281063, 249.0722244471137, 99.91745762178392, 47.25794455239392, 18.634917507008858, -6.2046707905064045, -30.30501322793394, -55.00924145570309, -119.0279148438982, -151.9787434645906, -179.0374650135084, -204.7887744010924, -414.95472239851756, -416.80784713659705, -417.0203038392698, -416.2298589514386, -417.30954265210096, -416.7397013645, -416.5376448331866, -416.3452735360466, -415.8448841717108, -416.2807015282822, -416.7264296777435, -416.4694184012079, -415.8813777943306, -415.9557770844878, -417.4453808506332, -416.82860991031157, -417.6394890928247, -415.81584836531886, -416.8417194281566, -417.4996679223598, -417.41176147643006, -417.48854570358543, -417.1000376763398, -417.10141294802963, -416.3923360794847, -417.0121240636091, -417.05004705815514, -418.12359874618323, -418.01224514687453, -416.4127277730523, -422.0891226907198, -30.752849865510562, -1.2259568986356288, 27.24195647786061, 59.004360495425246, 98.75089143535536, 132.81631507130336, 169.27702847075787, 203.31215875822107, 240.5552082242872, 276.92910320385334, 314.7504059732243, 351.4507438412913, 393.4477121097114, 434.1972318973017, 476.0088242090501, 520.5114526223051, 568.8673441155173, 617.1719286865317, 667.754251266424, 724.4839326121544, 805.9957100923801, 867.0187036958375, 944.3936603886353, 1020.5642214588767, 1116.7136102316413, 1320.8938726360498, 1328.531665751701, 2570.4199197537755], [-547.0133171051218, -319.7048745992223, -161.97386382805269, -11.341418812836597, 139.1865135527484, 289.22813249279346, 445.94017338779946, 1256.1708513306025, 434.56121804632807, 453.0837918332637, 472.46779913958255, 489.78484232741323, 507.44925221769915, 526.4005612553684, 542.6352085334775, 555.8425782099374, 573.3468205566862, 597.0410077119973, 733.9619183144359, 733.4641617629924, 737.6109969950637, 756.0284564809493, 832.525526132622, 652.7916487491877, 626.7230168499534, 598.7178505442955, 606.7436494708904, 624.8332144296334, 729.6046312818428, 743.8837436286158, 726.5147270506887, 709.7979433467657, 172.80864665626325, 152.99417820739177, 133.11321754733115, 117.51150802055753, 98.38347478867735, 79.47379320648666, 62.832737779139364, 47.091540686141634, 31.0166456635214, 13.513975548344128, -4.432302792080098, -21.02911164456578, -36.72777700718167, -54.41545286074412, -69.85639918053172, -86.70047554793055, -103.40367329202746, -122.55378512404332, -140.86511613660065, -156.8758339729842, -176.6436635748474, -195.5103941132165, -215.54073529241728, -237.03686172567606, -259.24442608139026, -282.603876271995, -305.96865974931256, -330.54750970403757, -358.5963265390058, -385.56022895081617, -422.54980180586824, -751.3709218655919, -749.2489970161339, -750.7559112702733, -774.0042299254739, -864.6290094258477, -859.8022019341893, -863.3106915428015, -861.3298822757005, -861.0279854895367, -860.2757315528025, -856.7641124835297, -853.7405561137429, -858.3746037340769, -856.1966852381063, -854.3416174312929, -856.1961385623143, -858.9557656241429, -857.7991448709579, -856.129267351384, -856.742103194904, -750.7817028355712, -747.4831970964896, -752.045993751549, -746.598231901226, -753.2328409750957, -680.7608810974227, -618.6225530119403, -639.3887695549508]])
    print('template: ' + str(template.shape))
    data = numpy.array([[4064.2784829979987, 3904.405249585708, 1386.0107833866005, 383.621557032041, 292.95054549599826, 238.10070013676906, 208.6067953384648, 189.13563702310756, 179.22888248747415, 164.45816026164047, 148.1893377940878, 128.28609088384334, 113.2594198026199, 93.84250327262558, 78.17503471742116, 49.86751734666005, -252.38185079120632, -279.14072697323104, -297.99472168744313, -321.83496336645817, -400.85988274539716, -475.1071786806791, -500.08120140486324, -705.4817096354477, -826.3969126265803, -726.3842716261097, -725.1770817719618, -725.9463959908949, -727.1304669884391, -727.6951116825528, -728.4221341663099, -730.4474121816637, -733.8551023712645, -704.5166949857198, -702.6826667396905, -706.1329806875009, -717.0647730095053, -317.50233376048556, -274.99000184806846, -214.02838098007032, -174.3998910825074, -138.04058322130308, -101.4023710915645, -64.98490962594906, -29.98694202430226, 4.488407701622379, 39.596624406789836, 73.00983466055915, 110.0929361020061, 145.98460738376951, 182.59592962857158, 219.09161598607963, 257.00683571107675, 296.2118803127923, 335.249360948422, 373.347665619674, 416.4145860685503, 455.5147992093123, 485.07013136836406, 532.0919778836491, 577.5333184577491, 630.3848219149238, 683.9585819956407, 737.1996904223477, 755.511528133502, 977.5098864775325, 996.2127332764118, 1015.0229713204523, 1009.1936501705902, 2231.159478731532], [-567.806723401092, -68.1516471375923, 1651.7833304752965, 568.4079199662093, 485.7494625767455, 439.3837947562249, 425.34958262424084, 432.7213575822937, 451.7444052584284, 468.47173182952736, 483.2909787738125, 494.3766189715512, 509.56481808105036, 524.6737887292705, 559.5656028982928, 718.772203631777, 638.155517010709, 630.1952213757703, 606.7743780404899, 593.9044589451324, 683.9326844838946, 745.7688859600441, 717.0996126769758, 734.9470184100659, 733.5483234261095, 171.0407917258515, 140.9601453344226, 110.11309026555759, 79.83441599444706, 51.28425131867585, 21.857652129140334, -8.76516041556689, -36.252602991523034, -93.92437908444349, -122.32183927491077, -152.91325510035244, -184.81980767446595, -760.6446808836864, -745.3930163904135, -878.8128937009571, -874.2750871381442, -876.192785512368, -864.825486232343, -868.0709714769336, -865.4806660509703, -866.2383717524317, -868.848185723828, -867.1820031243948, -867.2903826979979, -872.3696145596812, -869.5349196455986, -871.6366366236612, -871.128893389365, -874.1781980589312, -871.2233444896175, -867.0337482337928, -869.9765183666499, -784.0292278998915, -759.577863128118, -767.0074165690096, -766.8476159389036, -771.1231913898646, -771.8012831127662, -767.5706344963926, -615.9057503850576, -740.7946219018341, -690.2928292094167, -644.3084899268365, -583.0252365510091, -773.6986690349399]])
    print('data: ' + str(data.shape))
    T,error = icp(data,template)
    dx = T[0,2]
    dy = T[1,2]
    rotation = numpy.arcsin(T[0,1]) * 360 / 2 / numpy.pi

    print("T",T)
    print("error",error)
    print("rotation°",rotation)
    print("dx",dx)
    print("dy",dy)

    result = cv2.transform(numpy.array([data.T], copy=True).astype(numpy.float32), T).T
    matplotlib.pyplot.scatter(template[0], template[1], label="template")
    matplotlib.pyplot.scatter(data[0], data[1], label="data")
    matplotlib.pyplot.scatter(result[0], result[1], label="result: "+str(rotation)+"° - "+str([dx,dy]))
    matplotlib.pyplot.legend(loc="upper left")
    matplotlib.pyplot.axis('square')
    matplotlib.pyplot.show()
